package net.minecraft.src;

import java.nio.IntBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import net.minecraft.client.Minecraft;

import org.lwjgl.BufferUtils;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.ARBOcclusionQuery;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL15;

public class RenderGlobal implements IWorldAccess {
	public List tileEntities = new ArrayList();
	public World worldObj;
	public RenderEngine renderEngine;
	public List worldRenderersToUpdate = new ArrayList();
	private WorldRenderer[] sortedWorldRenderers;
	private WorldRenderer[] worldRenderers;
	private int renderChunksWide;
	private int renderChunksTall;
	private int renderChunksDeep;
	private int glRenderListBase;
	public Minecraft mc;
	public RenderBlocks globalRenderBlocks;
	private IntBuffer glOcclusionQueryBase;
	private boolean occlusionEnabled = false;
	private int cloudOffsetX = 0;
	private int starGLCallList;
	private int glSkyList;
	private int glSkyList2;
	private int minBlockX;
	private int minBlockY;
	private int minBlockZ;
	private int maxBlockX;
	private int maxBlockY;
	private int maxBlockZ;
	private int renderDistance = -1;
	private int renderEntitiesStartupCounter = 2;
	private int countEntitiesTotal;
	private int countEntitiesRendered;
	private int countEntitiesHidden;
	int[] dummyBuf50k = new int[50000];
	IntBuffer occlusionResult = GLAllocation.createDirectIntBuffer(64);
	private int renderersLoaded;
	private int renderersBeingClipped;
	private int renderersBeingOccluded;
	private int renderersBeingRendered;
	private int renderersSkippingRenderPass;
	private int dummyRenderInt;
	private int worldRenderersCheckIndex;
	private IntBuffer glListBuffer = BufferUtils.createIntBuffer(65536);
	double prevSortX = -9999.0D;
	double prevSortY = -9999.0D;
	double prevSortZ = -9999.0D;
	public float damagePartialTime;
	int frustumCheckOffset = 0;
	double prevReposX;
	double prevReposY;
	double prevReposZ;
	private long lastMovedTime = System.currentTimeMillis();
	private long lastActionTime = System.currentTimeMillis();

	public RenderGlobal(Minecraft par1Minecraft, RenderEngine par2RenderEngine) {
		this.mc = par1Minecraft;
		this.renderEngine = par2RenderEngine;
		byte maxChunkDim = 65;
		byte maxChunkHeight = 16;
		this.glRenderListBase = GLAllocation.generateDisplayLists(maxChunkDim * maxChunkDim * maxChunkHeight * 3);
		this.occlusionEnabled = OpenGlCapsChecker.checkARBOcclusion();
		if(this.occlusionEnabled) {
			this.occlusionResult.clear();
			this.glOcclusionQueryBase = GLAllocation.createDirectIntBuffer(maxChunkDim * maxChunkDim * maxChunkHeight);
			this.glOcclusionQueryBase.clear();
			this.glOcclusionQueryBase.position(0);
			this.glOcclusionQueryBase.limit(maxChunkDim * maxChunkDim * maxChunkHeight);
			ARBOcclusionQuery.glGenQueriesARB(this.glOcclusionQueryBase);
		}

		this.starGLCallList = GLAllocation.generateDisplayLists(3);
		GL11.glPushMatrix();
		GL11.glNewList(this.starGLCallList, GL11.GL_COMPILE);
		this.renderStars();
		GL11.glEndList();
		GL11.glPopMatrix();
		Tessellator tessellator = Tessellator.instance;
		this.glSkyList = this.starGLCallList + 1;
		GL11.glNewList(this.glSkyList, GL11.GL_COMPILE);
		byte byte2 = 64;
		int i = 256 / byte2 + 2;
		float f = 16.0F;

		int k;
		int i1;
		for(k = -byte2 * i; k <= byte2 * i; k += byte2) {
			for(i1 = -byte2 * i; i1 <= byte2 * i; i1 += byte2) {
				tessellator.startDrawingQuads();
				tessellator.addVertex((double)(k + 0), (double)f, (double)(i1 + 0));
				tessellator.addVertex((double)(k + byte2), (double)f, (double)(i1 + 0));
				tessellator.addVertex((double)(k + byte2), (double)f, (double)(i1 + byte2));
				tessellator.addVertex((double)(k + 0), (double)f, (double)(i1 + byte2));
				tessellator.draw();
			}
		}

		GL11.glEndList();
		this.glSkyList2 = this.starGLCallList + 2;
		GL11.glNewList(this.glSkyList2, GL11.GL_COMPILE);
		f = -16.0F;
		tessellator.startDrawingQuads();

		for(k = -byte2 * i; k <= byte2 * i; k += byte2) {
			for(i1 = -byte2 * i; i1 <= byte2 * i; i1 += byte2) {
				tessellator.addVertex((double)(k + byte2), (double)f, (double)(i1 + 0));
				tessellator.addVertex((double)(k + 0), (double)f, (double)(i1 + 0));
				tessellator.addVertex((double)(k + 0), (double)f, (double)(i1 + byte2));
				tessellator.addVertex((double)(k + byte2), (double)f, (double)(i1 + byte2));
			}
		}

		tessellator.draw();
		GL11.glEndList();
		this.renderEngine.updateDynamicTextures();
	}

	private void renderStars() {
		Random random = new Random(10842L);
		Tessellator tessellator = Tessellator.instance;
		tessellator.startDrawingQuads();

		for(int i = 0; i < 1500; ++i) {
			double d = (double)(random.nextFloat() * 2.0F - 1.0F);
			double d1 = (double)(random.nextFloat() * 2.0F - 1.0F);
			double d2 = (double)(random.nextFloat() * 2.0F - 1.0F);
			double d3 = (double)(0.25F + random.nextFloat() * 0.25F);
			double d4 = d * d + d1 * d1 + d2 * d2;
			if(d4 < 1.0D && d4 > 0.01D) {
				d4 = 1.0D / Math.sqrt(d4);
				d *= d4;
				d1 *= d4;
				d2 *= d4;
				double d5 = d * 100.0D;
				double d6 = d1 * 100.0D;
				double d7 = d2 * 100.0D;
				double d8 = Math.atan2(d, d2);
				double d9 = Math.sin(d8);
				double d10 = Math.cos(d8);
				double d11 = Math.atan2(Math.sqrt(d * d + d2 * d2), d1);
				double d12 = Math.sin(d11);
				double d13 = Math.cos(d11);
				double d14 = random.nextDouble() * Math.PI * 2.0D;
				double d15 = Math.sin(d14);
				double d16 = Math.cos(d14);

				for(int j = 0; j < 4; ++j) {
					double d17 = 0.0D;
					double d18 = (double)((j & 2) - 1) * d3;
					double d19 = (double)((j + 1 & 2) - 1) * d3;
					double d21 = d18 * d16 - d19 * d15;
					double d22 = d19 * d16 + d18 * d15;
					double d24 = d21 * d12 + d17 * d13;
					double d25 = d17 * d12 - d21 * d13;
					double d26 = d25 * d9 - d22 * d10;
					double d28 = d22 * d9 + d25 * d10;
					tessellator.addVertex(d5 + d26, d6 + d24, d7 + d28);
				}
			}
		}

		tessellator.draw();
	}

	public void changeWorld(World par1World) {
		if(this.worldObj != null) {
			this.worldObj.removeWorldAccess(this);
		}

		this.prevSortX = -9999.0D;
		this.prevSortY = -9999.0D;
		this.prevSortZ = -9999.0D;
		RenderManager.instance.set(par1World);
		this.worldObj = par1World;
		this.globalRenderBlocks = new RenderBlocks(par1World);
		if(par1World != null) {
			par1World.addWorldAccess(this);
			this.loadRenderers();
		}

	}

	public void loadRenderers() {
		if(this.worldObj != null) {
			Block.leaves.setGraphicsLevel(Config.isTreesFancy());
			this.renderDistance = this.mc.gameSettings.renderDistance;
			int numBlocks;
			if(this.worldRenderers != null) {
				for(numBlocks = 0; numBlocks < this.worldRenderers.length; ++numBlocks) {
					this.worldRenderers[numBlocks].stopRendering();
				}
			}

			numBlocks = 64 << 3 - this.renderDistance;
			short numBlocksFar = 512;
			numBlocks = 2 * this.mc.gameSettings.ofRenderDistanceFine;
			if(Config.isLoadChunksFar() && numBlocks < numBlocksFar) {
				numBlocks = numBlocksFar;
			}

			numBlocks += Config.getPreloadedChunks() * 2 * 16;
			short limit = 400;
			if(this.mc.gameSettings.ofRenderDistanceFine > 256) {
				limit = 1024;
			}

			if(numBlocks > limit) {
				numBlocks = limit;
			}

			this.prevReposX = -9999.0D;
			this.prevReposY = -9999.0D;
			this.prevReposZ = -9999.0D;
			this.renderChunksWide = numBlocks / 16 + 1;
			this.renderChunksTall = 16;
			this.renderChunksDeep = numBlocks / 16 + 1;
			this.worldRenderers = new WorldRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
			this.sortedWorldRenderers = new WorldRenderer[this.renderChunksWide * this.renderChunksTall * this.renderChunksDeep];
			int k = 0;
			int l = 0;
			this.minBlockX = 0;
			this.minBlockY = 0;
			this.minBlockZ = 0;
			this.maxBlockX = this.renderChunksWide;
			this.maxBlockY = this.renderChunksTall;
			this.maxBlockZ = this.renderChunksDeep;

			int entityliving;
			for(entityliving = 0; entityliving < this.worldRenderersToUpdate.size(); ++entityliving) {
				WorldRenderer k1 = (WorldRenderer)this.worldRenderersToUpdate.get(entityliving);
				if(k1 != null) {
					k1.needsUpdate = false;
				}
			}

			this.worldRenderersToUpdate.clear();
			this.tileEntities.clear();

			for(entityliving = 0; entityliving < this.renderChunksWide; ++entityliving) {
				for(int i10 = 0; i10 < this.renderChunksTall; ++i10) {
					for(int l1 = 0; l1 < this.renderChunksDeep; ++l1) {
						int wri = (l1 * this.renderChunksTall + i10) * this.renderChunksWide + entityliving;
						this.worldRenderers[wri] = WrUpdates.makeWorldRenderer(this.worldObj, this.tileEntities, entityliving * 16, i10 * 16, l1 * 16, this.glRenderListBase + k);
						if(this.occlusionEnabled) {
							this.worldRenderers[wri].glOcclusionQuery = this.glOcclusionQueryBase.get(l);
						}

						this.worldRenderers[wri].isWaitingOnOcclusionQuery = false;
						this.worldRenderers[wri].isVisible = true;
						this.worldRenderers[wri].isInFrustum = false;
						this.worldRenderers[wri].chunkIndex = l++;
						this.worldRenderers[wri].markDirty();
						this.sortedWorldRenderers[wri] = this.worldRenderers[wri];
						this.worldRenderersToUpdate.add(this.worldRenderers[wri]);
						k += 3;
					}
				}
			}

			if(this.worldObj != null) {
				Object object11 = this.mc.renderViewEntity;
				if(object11 == null) {
					object11 = this.mc.thePlayer;
				}

				if(object11 != null) {
					this.markRenderersForNewPosition(MathHelper.floor_double(((Entity)object11).posX), MathHelper.floor_double(((Entity)object11).posY), MathHelper.floor_double(((Entity)object11).posZ));
					Arrays.sort(this.sortedWorldRenderers, new EntitySorter((Entity)object11));
				}
			}

			this.renderEntitiesStartupCounter = 2;
		}
	}

	public void renderEntities(Vec3D par1Vec3D, ICamera par2ICamera, float par3) {
		if(this.renderEntitiesStartupCounter > 0) {
			--this.renderEntitiesStartupCounter;
		} else {
			Profiler.startSection("prepare");
			TileEntityRenderer.instance.cacheActiveRenderInfo(this.worldObj, this.renderEngine, this.mc.fontRenderer, this.mc.renderViewEntity, par3);
			RenderManager.instance.cacheActiveRenderInfo(this.worldObj, this.renderEngine, this.mc.fontRenderer, this.mc.renderViewEntity, this.mc.gameSettings, par3);
			TileEntityRenderer.instance.func_40742_a();
			this.countEntitiesTotal = 0;
			this.countEntitiesRendered = 0;
			this.countEntitiesHidden = 0;
			EntityLiving entityliving = this.mc.renderViewEntity;
			RenderManager.renderPosX = entityliving.lastTickPosX + (entityliving.posX - entityliving.lastTickPosX) * (double)par3;
			RenderManager.renderPosY = entityliving.lastTickPosY + (entityliving.posY - entityliving.lastTickPosY) * (double)par3;
			RenderManager.renderPosZ = entityliving.lastTickPosZ + (entityliving.posZ - entityliving.lastTickPosZ) * (double)par3;
			TileEntityRenderer.staticPlayerX = entityliving.lastTickPosX + (entityliving.posX - entityliving.lastTickPosX) * (double)par3;
			TileEntityRenderer.staticPlayerY = entityliving.lastTickPosY + (entityliving.posY - entityliving.lastTickPosY) * (double)par3;
			TileEntityRenderer.staticPlayerZ = entityliving.lastTickPosZ + (entityliving.posZ - entityliving.lastTickPosZ) * (double)par3;
			this.mc.entityRenderer.enableLightmap((double)par3);
			Profiler.endStartSection("global");
			List list = this.worldObj.getLoadedEntityList();
			this.countEntitiesTotal = list.size();

			int k;
			Entity entity1;
			for(k = 0; k < this.worldObj.weatherEffects.size(); ++k) {
				entity1 = (Entity)this.worldObj.weatherEffects.get(k);
				++this.countEntitiesRendered;
				if(entity1.isInRangeToRenderVec3D(par1Vec3D)) {
					RenderManager.instance.renderEntity(entity1, par3);
				}
			}

			Profiler.endStartSection("entities");
			
			// PERRO

			for(k = 0; k < list.size(); ++k) {
				entity1 = (Entity)list.get(k);
				if(entity1.isInRangeToRenderVec3D(par1Vec3D) && (entity1.ignoreFrustumCheck || par2ICamera.isBoundingBoxInFrustum(entity1.boundingBox)) && (entity1 != this.mc.renderViewEntity || this.mc.gameSettings.thirdPersonView != 0 || this.mc.renderViewEntity.isPlayerSleeping()) && this.worldObj.blockExists(MathHelper.floor_double(entity1.posX), 0, MathHelper.floor_double(entity1.posZ))) {
					++this.countEntitiesRendered;
					RenderManager.instance.renderEntity(entity1, par3);
				}
			}

			Profiler.endStartSection("tileentities");
			RenderHelper.enableStandardItemLighting();

			for(k = 0; k < this.tileEntities.size(); ++k) {
				TileEntityRenderer.instance.renderTileEntity((TileEntity)this.tileEntities.get(k), par3);
			}

			this.mc.entityRenderer.disableLightmap((double)par3);
			Profiler.endSection();
		}
	}

	public String getDebugInfoRenders() {
		return "C: " + this.renderersBeingRendered + "/" + this.renderersLoaded + ". F: " + this.renderersBeingClipped + ", O: " + this.renderersBeingOccluded + ", E: " + this.renderersSkippingRenderPass;
	}

	public String getDebugInfoEntities() {
		return "E: " + this.countEntitiesRendered + "/" + this.countEntitiesTotal + ". B: " + this.countEntitiesHidden + ", I: " + (this.countEntitiesTotal - this.countEntitiesHidden - this.countEntitiesRendered) + ", " + Config.getVersion();
	}

	private void markRenderersForNewPosition(int x, int y, int z) {
		x -= 8;
		y -= 8;
		z -= 8;
		this.minBlockX = Integer.MAX_VALUE;
		this.minBlockY = Integer.MAX_VALUE;
		this.minBlockZ = Integer.MAX_VALUE;
		this.maxBlockX = Integer.MIN_VALUE;
		this.maxBlockY = Integer.MIN_VALUE;
		this.maxBlockZ = Integer.MIN_VALUE;
		int blocksWide = this.renderChunksWide * 16;
		int blocksWide2 = blocksWide / 2;

		for(int ix = 0; ix < this.renderChunksWide; ++ix) {
			int blockX = ix * 16;
			int blockXAbs = blockX + blocksWide2 - x;
			if(blockXAbs < 0) {
				blockXAbs -= blocksWide - 1;
			}

			blockXAbs /= blocksWide;
			blockX -= blockXAbs * blocksWide;
			if(blockX < this.minBlockX) {
				this.minBlockX = blockX;
			}

			if(blockX > this.maxBlockX) {
				this.maxBlockX = blockX;
			}

			for(int iz = 0; iz < this.renderChunksDeep; ++iz) {
				int blockZ = iz * 16;
				int blockZAbs = blockZ + blocksWide2 - z;
				if(blockZAbs < 0) {
					blockZAbs -= blocksWide - 1;
				}

				blockZAbs /= blocksWide;
				blockZ -= blockZAbs * blocksWide;
				if(blockZ < this.minBlockZ) {
					this.minBlockZ = blockZ;
				}

				if(blockZ > this.maxBlockZ) {
					this.maxBlockZ = blockZ;
				}

				for(int iy = 0; iy < this.renderChunksTall; ++iy) {
					int blockY = iy * 16;
					if(blockY < this.minBlockY) {
						this.minBlockY = blockY;
					}

					if(blockY > this.maxBlockY) {
						this.maxBlockY = blockY;
					}

					WorldRenderer worldrenderer = this.worldRenderers[(iz * this.renderChunksTall + iy) * this.renderChunksWide + ix];
					boolean wasNeedingUpdate = worldrenderer.needsUpdate;
					worldrenderer.setPosition(blockX, blockY, blockZ);
					if(!wasNeedingUpdate && worldrenderer.needsUpdate) {
						this.worldRenderersToUpdate.add(worldrenderer);
					}
				}
			}
		}

	}

	public int sortAndRender(EntityLiving player, int renderPass, double partialTicks) {
		Profiler.startSection("sortchunks");
		if(this.worldRenderersToUpdate.size() < 10) {
			byte partialX = 10;

			for(int i = 0; i < partialX; ++i) {
				this.worldRenderersCheckIndex = (this.worldRenderersCheckIndex + 1) % this.worldRenderers.length;
				WorldRenderer partialY = this.worldRenderers[this.worldRenderersCheckIndex];
				if(partialY.needsUpdate && !this.worldRenderersToUpdate.contains(partialY)) {
					this.worldRenderersToUpdate.add(partialY);
				}
			}
		}

		if(this.mc.gameSettings.renderDistance != this.renderDistance && !Config.isLoadChunksFar()) {
			this.loadRenderers();
		}

		if(renderPass == 0) {
			this.renderersLoaded = 0;
			this.dummyRenderInt = 0;
			this.renderersBeingClipped = 0;
			this.renderersBeingOccluded = 0;
			this.renderersBeingRendered = 0;
			this.renderersSkippingRenderPass = 0;
		}

		double d39 = player.lastTickPosX + (player.posX - player.lastTickPosX) * partialTicks;
		double d40 = player.lastTickPosY + (player.posY - player.lastTickPosY) * partialTicks;
		double partialZ = player.lastTickPosZ + (player.posZ - player.lastTickPosZ) * partialTicks;
		double dSortX = player.posX - this.prevSortX;
		double dSortY = player.posY - this.prevSortY;
		double dSortZ = player.posZ - this.prevSortZ;
		double distSqSort = dSortX * dSortX + dSortY * dSortY + dSortZ * dSortZ;
		int num;
		if(distSqSort > 16.0D) {
			this.prevSortX = player.posX;
			this.prevSortY = player.posY;
			this.prevSortZ = player.posZ;
			num = Config.getPreloadedChunks() * 16;
			double ocReq = player.posX - this.prevReposX;
			double lastIndex = player.posY - this.prevReposY;
			double stepNum = player.posZ - this.prevReposZ;
			double switchStep = ocReq * ocReq + lastIndex * lastIndex + stepNum * stepNum;
			if(switchStep > (double)(num * num) + 16.0D) {
				this.prevReposX = player.posX;
				this.prevReposY = player.posY;
				this.prevReposZ = player.posZ;
				this.markRenderersForNewPosition(MathHelper.floor_double(player.posX), MathHelper.floor_double(player.posY), MathHelper.floor_double(player.posZ));
			}

			Arrays.sort(this.sortedWorldRenderers, new EntitySorter(player));
			int sumTX = (int)player.posX;
			int sumTY = (int)player.posZ;
			short sumTZ = 2000;
			if(Math.abs(sumTX - WorldRenderer.globalChunkOffsetX) > sumTZ || Math.abs(sumTY - WorldRenderer.globalChunkOffsetZ) > sumTZ) {
				WorldRenderer.globalChunkOffsetX = sumTX;
				WorldRenderer.globalChunkOffsetZ = sumTY;
				this.loadRenderers();
			}
		}

		RenderHelper.disableStandardItemLighting();
		WrUpdates.preRender(this, player);
		if(this.mc.gameSettings.ofSmoothFps && renderPass == 0) {
			GL11.glFinish();
		}

		byte b41 = 0;
		int i42 = 0;
		if(this.occlusionEnabled && this.mc.gameSettings.advancedOpengl && !this.mc.gameSettings.anaglyph && renderPass == 0) {
			byte firstIndex = 0;
			byte b43 = 20;
			this.checkOcclusionQueryResult(firstIndex, b43, player.posX, player.posY, player.posZ);

			int endIndex;
			for(endIndex = firstIndex; endIndex < b43; ++endIndex) {
				this.sortedWorldRenderers[endIndex].isVisible = true;
			}

			Profiler.endStartSection("render");
			num = b41 + this.renderSortedRenderers(firstIndex, b43, renderPass, partialTicks);
			endIndex = b43;
			int i44 = 0;
			byte step = 30;

			int startIndex;
			for(int i45 = this.renderChunksWide / 2; endIndex < this.sortedWorldRenderers.length; num += this.renderSortedRenderers(startIndex, endIndex, renderPass, partialTicks)) {
				Profiler.endStartSection("occ");
				startIndex = endIndex;
				if(i44 < i45) {
					++i44;
				} else {
					--i44;
				}

				endIndex += i44 * step;
				if(endIndex <= startIndex) {
					endIndex = startIndex + 10;
				}

				if(endIndex > this.sortedWorldRenderers.length) {
					endIndex = this.sortedWorldRenderers.length;
				}

				GL11.glDisable(GL11.GL_TEXTURE_2D);
				GL11.glDisable(GL11.GL_LIGHTING);
				GL11.glDisable(GL11.GL_ALPHA_TEST);
				GL11.glDisable(GL11.GL_FOG);
				GL11.glColorMask(false, false, false, false);
				GL11.glDepthMask(false);
				Profiler.startSection("check");
				this.checkOcclusionQueryResult(startIndex, endIndex, player.posX, player.posY, player.posZ);
				Profiler.endSection();
				GL11.glPushMatrix();
				float f46 = 0.0F;
				float f47 = 0.0F;
				float f48 = 0.0F;

				for(int k = startIndex; k < endIndex; ++k) {
					WorldRenderer wr = this.sortedWorldRenderers[k];
					if(wr.skipAllRenderPasses()) {
						wr.isInFrustum = false;
					} else if(wr.isUpdating) {
						wr.isVisible = true;
					} else if(wr.isInFrustum) {
						if(Config.isOcclusionFancy() && !wr.isInFrustrumFully) {
							wr.isVisible = true;
						} else if(wr.isInFrustum && !wr.isWaitingOnOcclusionQuery) {
							float bbX;
							float bbY;
							float bbZ;
							float tX;
							if(wr.isVisibleFromPosition) {
								bbX = Math.abs((float)(wr.visibleFromX - player.posX));
								bbY = Math.abs((float)(wr.visibleFromY - player.posY));
								bbZ = Math.abs((float)(wr.visibleFromZ - player.posZ));
								tX = bbX + bbY + bbZ;
								if((double)tX < 10.0D + (double)k / 1000.0D) {
									wr.isVisible = true;
									continue;
								}

								wr.isVisibleFromPosition = false;
							}

							bbX = (float)((double)wr.posXMinus - d39);
							bbY = (float)((double)wr.posYMinus - d40);
							bbZ = (float)((double)wr.posZMinus - partialZ);
							tX = bbX - f46;
							float tY = bbY - f47;
							float tZ = bbZ - f48;
							if(tX != 0.0F || tY != 0.0F || tZ != 0.0F) {
								GL11.glTranslatef(tX, tY, tZ);
								f46 += tX;
								f47 += tY;
								f48 += tZ;
							}

							Profiler.startSection("bb");
							ARBOcclusionQuery.glBeginQueryARB(GL15.GL_SAMPLES_PASSED, wr.glOcclusionQuery);
							wr.callOcclusionQueryList();
							ARBOcclusionQuery.glEndQueryARB(GL15.GL_SAMPLES_PASSED);
							Profiler.endSection();
							wr.isWaitingOnOcclusionQuery = true;
							++i42;
						}
					}
				}

				GL11.glPopMatrix();
				if(this.mc.gameSettings.anaglyph) {
					if(EntityRenderer.anaglyphField == 0) {
						GL11.glColorMask(false, true, true, true);
					} else {
						GL11.glColorMask(true, false, false, true);
					}
				} else {
					GL11.glColorMask(true, true, true, true);
				}

				GL11.glDepthMask(true);
				GL11.glEnable(GL11.GL_TEXTURE_2D);
				GL11.glEnable(GL11.GL_ALPHA_TEST);
				GL11.glEnable(GL11.GL_FOG);
				Profiler.endStartSection("render");
			}
		} else {
			Profiler.endStartSection("render");
			num = b41 + this.renderSortedRenderers(0, this.sortedWorldRenderers.length, renderPass, partialTicks);
		}

		Profiler.endSection();
		WrUpdates.postRender();
		return num;
	}

	private void checkOcclusionQueryResult(int startIndex, int endIndex, double px, double py, double pz) {
		for(int k = startIndex; k < endIndex; ++k) {
			WorldRenderer wr = this.sortedWorldRenderers[k];
			if(wr.isWaitingOnOcclusionQuery) {
				this.occlusionResult.clear();
				ARBOcclusionQuery.glGetQueryObjectuARB(wr.glOcclusionQuery, GL15.GL_QUERY_RESULT_AVAILABLE, this.occlusionResult);
				if(this.occlusionResult.get(0) != 0) {
					wr.isWaitingOnOcclusionQuery = false;
					this.occlusionResult.clear();
					ARBOcclusionQuery.glGetQueryObjectuARB(wr.glOcclusionQuery, GL15.GL_QUERY_RESULT, this.occlusionResult);
					boolean wasVisible = wr.isVisible;
					wr.isVisible = this.occlusionResult.get(0) > 0;
					if(wasVisible && wr.isVisible) {
						wr.isVisibleFromPosition = true;
						wr.visibleFromX = px;
						wr.visibleFromY = py;
						wr.visibleFromZ = pz;
					}
				}
			}
		}

	}

	private int renderSortedRenderers(int startIndex, int endIndex, int renderPass, double partialTicks) {
		if(Config.isFogOff()) {
			GL11.glDisable(GL11.GL_FOG);
		}

		this.glListBuffer.clear();
		int l = 0;

		for(int entityliving = startIndex; entityliving < endIndex; ++entityliving) {
			WorldRenderer partialX = this.sortedWorldRenderers[entityliving];
			if(renderPass == 0) {
				++this.renderersLoaded;
				if(partialX.skipRenderPass[renderPass]) {
					++this.renderersSkippingRenderPass;
				} else if(!partialX.isInFrustum) {
					++this.renderersBeingClipped;
				} else if(this.occlusionEnabled && !partialX.isVisible) {
					++this.renderersBeingOccluded;
				} else {
					++this.renderersBeingRendered;
				}
			}

			if(!partialX.skipRenderPass[renderPass] && partialX.isInFrustum && (!this.occlusionEnabled || partialX.isVisible)) {
				int glCallList = partialX.getGLCallListForPass(renderPass);
				if(glCallList >= 0) {
					this.glListBuffer.put(glCallList);
					++l;
				}
			}
		}

		this.glListBuffer.flip();
		EntityLiving entityLiving14 = this.mc.renderViewEntity;
		double d15 = entityLiving14.lastTickPosX + (entityLiving14.posX - entityLiving14.lastTickPosX) * partialTicks - (double)WorldRenderer.globalChunkOffsetX;
		double partialY = entityLiving14.lastTickPosY + (entityLiving14.posY - entityLiving14.lastTickPosY) * partialTicks;
		double partialZ = entityLiving14.lastTickPosZ + (entityLiving14.posZ - entityLiving14.lastTickPosZ) * partialTicks - (double)WorldRenderer.globalChunkOffsetZ;
		this.mc.entityRenderer.enableLightmap(partialTicks);
		GL11.glTranslatef((float)(-d15), (float)(-partialY), (float)(-partialZ));
		GL11.glCallLists(this.glListBuffer);
		GL11.glTranslatef((float)d15, (float)partialY, (float)partialZ);
		this.mc.entityRenderer.disableLightmap(partialTicks);
		return l;
	}

	public void renderAllRenderLists(int par1, double par2) {
	}

	public void updateClouds() {
		++this.cloudOffsetX;
	}

	public void renderSky(float par1) {
		if(this.mc.theWorld.worldProvider.worldType == 1) {
			if(Config.isSkyEnabled()) {
				GL11.glDisable(GL11.GL_FOG);
				GL11.glDisable(GL11.GL_ALPHA_TEST);
				GL11.glEnable(GL11.GL_BLEND);
				GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
				RenderHelper.disableStandardItemLighting();
				GL11.glDepthMask(false);
				this.renderEngine.bindTexture(this.renderEngine.getTexture("/misc/tunnel.png"));
				Tessellator tessellator21 = Tessellator.instance;

				for(int i22 = 0; i22 < 6; ++i22) {
					GL11.glPushMatrix();
					if(i22 == 1) {
						GL11.glRotatef(90.0F, 1.0F, 0.0F, 0.0F);
					}

					if(i22 == 2) {
						GL11.glRotatef(-90.0F, 1.0F, 0.0F, 0.0F);
					}

					if(i22 == 3) {
						GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
					}

					if(i22 == 4) {
						GL11.glRotatef(90.0F, 0.0F, 0.0F, 1.0F);
					}

					if(i22 == 5) {
						GL11.glRotatef(-90.0F, 0.0F, 0.0F, 1.0F);
					}

					tessellator21.startDrawingQuads();
					tessellator21.setColorOpaque_I(1579032);
					tessellator21.addVertexWithUV(-100.0D, -100.0D, -100.0D, 0.0D, 0.0D);
					tessellator21.addVertexWithUV(-100.0D, -100.0D, 100.0D, 0.0D, 16.0D);
					tessellator21.addVertexWithUV(100.0D, -100.0D, 100.0D, 16.0D, 16.0D);
					tessellator21.addVertexWithUV(100.0D, -100.0D, -100.0D, 16.0D, 0.0D);
					tessellator21.draw();
					GL11.glPopMatrix();
				}

				GL11.glDepthMask(true);
				GL11.glEnable(GL11.GL_TEXTURE_2D);
				GL11.glEnable(GL11.GL_ALPHA_TEST);
			}
		} else if(this.mc.theWorld.worldProvider.func_48217_e()) {
			GL11.glDisable(GL11.GL_TEXTURE_2D);
			Vec3D vec3d = this.worldObj.getSkyColor(this.mc.renderViewEntity, par1);
			vec3d = CustomColorizer.getSkyColor(vec3d, this.mc.theWorld, this.mc.renderViewEntity.posX, this.mc.renderViewEntity.posY + 1.0D, this.mc.renderViewEntity.posZ);
			float f = (float)vec3d.xCoord;
			float f1 = (float)vec3d.yCoord;
			float f2 = (float)vec3d.zCoord;
			float d;
			if(this.mc.gameSettings.anaglyph) {
				float tessellator1 = (f * 30.0F + f1 * 59.0F + f2 * 11.0F) / 100.0F;
				float af = (f * 30.0F + f1 * 70.0F) / 100.0F;
				d = (f * 30.0F + f2 * 70.0F) / 100.0F;
				f = tessellator1;
				f1 = af;
				f2 = d;
			}

			GL11.glColor3f(f, f1, f2);
			Tessellator tessellator23 = Tessellator.instance;
			GL11.glDepthMask(false);
			GL11.glEnable(GL11.GL_FOG);
			GL11.glColor3f(f, f1, f2);
			if(Config.isSkyEnabled()) {
				GL11.glCallList(this.glSkyList);
			}

			GL11.glDisable(GL11.GL_FOG);
			GL11.glDisable(GL11.GL_ALPHA_TEST);
			GL11.glEnable(GL11.GL_BLEND);
			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
			RenderHelper.disableStandardItemLighting();
			float[] f24 = this.worldObj.worldProvider.calcSunriseSunsetColors(this.worldObj.getCelestialAngle(par1), par1);
			float f7;
			float f9;
			float f12;
			float f18;
			float f10;
			float f13;
			if(f24 != null && Config.isSunMoonEnabled()) {
				GL11.glDisable(GL11.GL_TEXTURE_2D);
				GL11.glShadeModel(GL11.GL_SMOOTH);
				GL11.glPushMatrix();
				GL11.glRotatef(90.0F, 1.0F, 0.0F, 0.0F);
				GL11.glRotatef(MathHelper.sin(this.worldObj.getCelestialAngleRadians(par1)) >= 0.0F ? 0.0F : 180.0F, 0.0F, 0.0F, 1.0F);
				GL11.glRotatef(90.0F, 0.0F, 0.0F, 1.0F);
				d = f24[0];
				float f8 = f24[1];
				f7 = f24[2];
				if(this.mc.gameSettings.anaglyph) {
					f9 = (d * 30.0F + f8 * 59.0F + f7 * 11.0F) / 100.0F;
					f12 = (d * 30.0F + f8 * 70.0F) / 100.0F;
					f18 = (d * 30.0F + f7 * 70.0F) / 100.0F;
					d = f9;
					f8 = f12;
					f7 = f18;
				}

				tessellator23.startDrawing(6);
				tessellator23.setColorRGBA_F(d, f8, f7, f24[3]);
				tessellator23.addVertex(0.0D, 100.0D, 0.0D);
				byte b26 = 16;
				tessellator23.setColorRGBA_F(f24[0], f24[1], f24[2], 0.0F);

				for(int i27 = 0; i27 <= b26; ++i27) {
					f18 = (float)i27 * (float)Math.PI * 2.0F / (float)b26;
					f10 = MathHelper.sin(f18);
					f13 = MathHelper.cos(f18);
					tessellator23.addVertex((double)(f10 * 120.0F), (double)(f13 * 120.0F), (double)(-f13 * 40.0F * f24[3]));
				}

				tessellator23.draw();
				GL11.glPopMatrix();
				GL11.glShadeModel(GL11.GL_FLAT);
			}

			GL11.glEnable(GL11.GL_TEXTURE_2D);
			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE);
			GL11.glPushMatrix();
			double d25 = (double)(1.0F - this.worldObj.getRainStrength(par1));
			f7 = 0.0F;
			f9 = 0.0F;
			f12 = 0.0F;
			GL11.glColor4f(1.0F, 1.0F, 1.0F, (float)d25);
			GL11.glTranslatef(f7, f9, f12);
			GL11.glRotatef(-90.0F, 0.0F, 1.0F, 0.0F);
			GL11.glRotatef(this.worldObj.getCelestialAngle(par1) * 360.0F, 1.0F, 0.0F, 0.0F);
			if(Config.isSunMoonEnabled()) {
				f18 = 30.0F;
				GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/terrain/sun.png"));
				tessellator23.startDrawingQuads();
				tessellator23.addVertexWithUV((double)(-f18), 100.0D, (double)(-f18), 0.0D, 0.0D);
				tessellator23.addVertexWithUV((double)f18, 100.0D, (double)(-f18), 1.0D, 0.0D);
				tessellator23.addVertexWithUV((double)f18, 100.0D, (double)f18, 1.0D, 1.0D);
				tessellator23.addVertexWithUV((double)(-f18), 100.0D, (double)f18, 0.0D, 1.0D);
				tessellator23.draw();
				f18 = 20.0F;
				GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/terrain/moon_phases.png"));
				int i28 = this.worldObj.getMoonPhase(par1);
				int i29 = i28 % 4;
				int f16 = i28 / 4 % 2;
				float f19 = (float)(i29 + 0) / 4.0F;
				float f25 = (float)(f16 + 0) / 2.0F;
				float f26 = (float)(i29 + 1) / 4.0F;
				float f27 = (float)(f16 + 1) / 2.0F;
				tessellator23.startDrawingQuads();
				tessellator23.addVertexWithUV((double)(-f18), -100.0D, (double)f18, (double)f26, (double)f27);
				tessellator23.addVertexWithUV((double)f18, -100.0D, (double)f18, (double)f19, (double)f27);
				tessellator23.addVertexWithUV((double)f18, -100.0D, (double)(-f18), (double)f19, (double)f25);
				tessellator23.addVertexWithUV((double)(-f18), -100.0D, (double)(-f18), (double)f26, (double)f25);
				tessellator23.draw();
			}

			GL11.glDisable(GL11.GL_TEXTURE_2D);
			f18 = (float)((double)this.worldObj.getStarBrightness(par1) * d25);
			if(f18 > 0.0F && Config.isStarsEnabled()) {
				GL11.glColor4f(f18, f18, f18, f18);
				GL11.glCallList(this.starGLCallList);
			}

			GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
			GL11.glDisable(GL11.GL_BLEND);
			GL11.glEnable(GL11.GL_ALPHA_TEST);
			GL11.glEnable(GL11.GL_FOG);
			GL11.glPopMatrix();
			GL11.glDisable(GL11.GL_TEXTURE_2D);
			GL11.glColor3f(0.0F, 0.0F, 0.0F);
			d25 = this.mc.thePlayer.getPosition(par1).yCoord - this.worldObj.getSeaLevel();
			if(d25 < 0.0D && Config.isSkyEnabled()) {
				GL11.glPushMatrix();
				GL11.glTranslatef(0.0F, 12.0F, 0.0F);
				GL11.glCallList(this.glSkyList2);
				GL11.glPopMatrix();
				f10 = 1.0F;
				f13 = -((float)(d25 + 65.0D));
				float f30 = -f10;
				tessellator23.startDrawingQuads();
				tessellator23.setColorRGBA_I(0, 255);
				tessellator23.addVertex((double)(-f10), (double)f13, (double)f10);
				tessellator23.addVertex((double)f10, (double)f13, (double)f10);
				tessellator23.addVertex((double)f10, (double)f30, (double)f10);
				tessellator23.addVertex((double)(-f10), (double)f30, (double)f10);
				tessellator23.addVertex((double)(-f10), (double)f30, (double)(-f10));
				tessellator23.addVertex((double)f10, (double)f30, (double)(-f10));
				tessellator23.addVertex((double)f10, (double)f13, (double)(-f10));
				tessellator23.addVertex((double)(-f10), (double)f13, (double)(-f10));
				tessellator23.addVertex((double)f10, (double)f30, (double)(-f10));
				tessellator23.addVertex((double)f10, (double)f30, (double)f10);
				tessellator23.addVertex((double)f10, (double)f13, (double)f10);
				tessellator23.addVertex((double)f10, (double)f13, (double)(-f10));
				tessellator23.addVertex((double)(-f10), (double)f13, (double)(-f10));
				tessellator23.addVertex((double)(-f10), (double)f13, (double)f10);
				tessellator23.addVertex((double)(-f10), (double)f30, (double)f10);
				tessellator23.addVertex((double)(-f10), (double)f30, (double)(-f10));
				tessellator23.addVertex((double)(-f10), (double)f30, (double)(-f10));
				tessellator23.addVertex((double)(-f10), (double)f30, (double)f10);
				tessellator23.addVertex((double)f10, (double)f30, (double)f10);
				tessellator23.addVertex((double)f10, (double)f30, (double)(-f10));
				tessellator23.draw();
			}

			if(this.worldObj.worldProvider.isSkyColored()) {
				GL11.glColor3f(f * 0.2F + 0.04F, f1 * 0.2F + 0.04F, f2 * 0.6F + 0.1F);
			} else {
				GL11.glColor3f(f, f1, f2);
			}

			if(this.mc.gameSettings.ofRenderDistanceFine <= 64) {
				GL11.glColor3f(this.mc.entityRenderer.fogColorRed, this.mc.entityRenderer.fogColorGreen, this.mc.entityRenderer.fogColorBlue);
			}

			GL11.glPushMatrix();
			GL11.glTranslatef(0.0F, -((float)(d25 - 16.0D)), 0.0F);
			if(Config.isSkyEnabled()) {
				GL11.glCallList(this.glSkyList2);
			}

			GL11.glPopMatrix();
			GL11.glEnable(GL11.GL_TEXTURE_2D);
			GL11.glDepthMask(true);
		}
	}

	public void renderClouds(float par1) {
		if(this.mc.theWorld.worldProvider.func_48217_e()) {
			if(this.mc.gameSettings.ofClouds != 3) {
				if(Config.isCloudsFancy()) {
					this.renderCloudsFancy(par1);
				} else {
					GL11.glDisable(GL11.GL_CULL_FACE);
					float f = (float)(this.mc.renderViewEntity.lastTickPosY + (this.mc.renderViewEntity.posY - this.mc.renderViewEntity.lastTickPosY) * (double)par1);
					byte byte0 = 32;
					int i = 256 / byte0;
					Tessellator tessellator = Tessellator.instance;
					GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/environment/clouds.png"));
					GL11.glEnable(GL11.GL_BLEND);
					GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
					Vec3D vec3d = this.worldObj.drawClouds(par1);
					float f1 = (float)vec3d.xCoord;
					float f2 = (float)vec3d.yCoord;
					float f3 = (float)vec3d.zCoord;
					float f5;
					if(this.mc.gameSettings.anaglyph) {
						f5 = (f1 * 30.0F + f2 * 59.0F + f3 * 11.0F) / 100.0F;
						float d = (f1 * 30.0F + f2 * 70.0F) / 100.0F;
						float f7 = (f1 * 30.0F + f3 * 70.0F) / 100.0F;
						f1 = f5;
						f2 = d;
						f3 = f7;
					}

					f5 = 4.882813E-4F;
					double d1 = (double)((float)this.cloudOffsetX + par1);
					double d1 = this.mc.renderViewEntity.prevPosX + (this.mc.renderViewEntity.posX - this.mc.renderViewEntity.prevPosX) * (double)par1 + d1 * (double)0.03F;
					double d2 = this.mc.renderViewEntity.prevPosZ + (this.mc.renderViewEntity.posZ - this.mc.renderViewEntity.prevPosZ) * (double)par1;
					int j = MathHelper.floor_double(d1 / 2048.0D);
					int k = MathHelper.floor_double(d2 / 2048.0D);
					d1 -= (double)(j * 2048);
					d2 -= (double)(k * 2048);
					float f8 = this.worldObj.worldProvider.getCloudHeight() - f + 0.33F;
					f8 += this.mc.gameSettings.ofCloudsHeight * 128.0F;
					float f9 = (float)(d1 * (double)f5);
					float f10 = (float)(d2 * (double)f5);
					tessellator.startDrawingQuads();
					tessellator.setColorRGBA_F(f1, f2, f3, 0.8F);

					for(int l = -byte0 * i; l < byte0 * i; l += byte0) {
						for(int i1 = -byte0 * i; i1 < byte0 * i; i1 += byte0) {
							tessellator.addVertexWithUV((double)(l + 0), (double)f8, (double)(i1 + byte0), (double)((float)(l + 0) * f5 + f9), (double)((float)(i1 + byte0) * f5 + f10));
							tessellator.addVertexWithUV((double)(l + byte0), (double)f8, (double)(i1 + byte0), (double)((float)(l + byte0) * f5 + f9), (double)((float)(i1 + byte0) * f5 + f10));
							tessellator.addVertexWithUV((double)(l + byte0), (double)f8, (double)(i1 + 0), (double)((float)(l + byte0) * f5 + f9), (double)((float)(i1 + 0) * f5 + f10));
							tessellator.addVertexWithUV((double)(l + 0), (double)f8, (double)(i1 + 0), (double)((float)(l + 0) * f5 + f9), (double)((float)(i1 + 0) * f5 + f10));
						}
					}

					tessellator.draw();
					GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
					GL11.glDisable(GL11.GL_BLEND);
					GL11.glEnable(GL11.GL_CULL_FACE);
				}
			}
		}
	}

	public boolean func_27307_a(double par1, double par3, double d, float f) {
		return false;
	}

	public void renderCloudsFancy(float par1) {
		GL11.glDisable(GL11.GL_CULL_FACE);
		float f = (float)(this.mc.renderViewEntity.lastTickPosY + (this.mc.renderViewEntity.posY - this.mc.renderViewEntity.lastTickPosY) * (double)par1);
		Tessellator tessellator = Tessellator.instance;
		float f1 = 12.0F;
		float f2 = 4.0F;
		double d = (double)((float)this.cloudOffsetX + par1);
		double d1 = (this.mc.renderViewEntity.prevPosX + (this.mc.renderViewEntity.posX - this.mc.renderViewEntity.prevPosX) * (double)par1 + d * (double)0.03F) / (double)f1;
		double d2 = (this.mc.renderViewEntity.prevPosZ + (this.mc.renderViewEntity.posZ - this.mc.renderViewEntity.prevPosZ) * (double)par1) / (double)f1 + (double)0.33F;
		float f3 = this.worldObj.worldProvider.getCloudHeight() - f + 0.33F;
		f3 += this.mc.gameSettings.ofCloudsHeight * 128.0F;
		int i = MathHelper.floor_double(d1 / 2048.0D);
		int j = MathHelper.floor_double(d2 / 2048.0D);
		d1 -= (double)(i * 2048);
		d2 -= (double)(j * 2048);
		GL11.glBindTexture(GL11.GL_TEXTURE_2D, this.renderEngine.getTexture("/environment/clouds.png"));
		GL11.glEnable(GL11.GL_BLEND);
		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
		Vec3D vec3d = this.worldObj.drawClouds(par1);
		float f4 = (float)vec3d.xCoord;
		float f5 = (float)vec3d.yCoord;
		float f6 = (float)vec3d.zCoord;
		float f8;
		float f10;
		float f12;
		if(this.mc.gameSettings.anaglyph) {
			f8 = (f4 * 30.0F + f5 * 59.0F + f6 * 11.0F) / 100.0F;
			f10 = (f4 * 30.0F + f5 * 70.0F) / 100.0F;
			f12 = (f4 * 30.0F + f6 * 70.0F) / 100.0F;
			f4 = f8;
			f5 = f10;
			f6 = f12;
		}

		f8 = (float)(d1 * 0.0D);
		f10 = (float)(d2 * 0.0D);
		f12 = 0.00390625F;
		f8 = (float)MathHelper.floor_double(d1) * f12;
		f10 = (float)MathHelper.floor_double(d2) * f12;
		float f13 = (float)(d1 - (double)MathHelper.floor_double(d1));
		float f14 = (float)(d2 - (double)MathHelper.floor_double(d2));
		byte k = 8;
		byte byte0 = 4;
		float f15 = 9.765625E-4F;
		GL11.glScalef(f1, 1.0F, f1);

		for(int l = 0; l < 2; ++l) {
			if(l == 0) {
				GL11.glColorMask(false, false, false, false);
			} else if(this.mc.gameSettings.anaglyph) {
				if(EntityRenderer.anaglyphField == 0) {
					GL11.glColorMask(false, true, true, true);
				} else {
					GL11.glColorMask(true, false, false, true);
				}
			} else {
				GL11.glColorMask(true, true, true, true);
			}

			for(int i1 = -byte0 + 1; i1 <= byte0; ++i1) {
				for(int j1 = -byte0 + 1; j1 <= byte0; ++j1) {
					tessellator.startDrawingQuads();
					float f16 = (float)(i1 * k);
					float f17 = (float)(j1 * k);
					float f18 = f16 - f13;
					float f19 = f17 - f14;
					if(f3 > -f2 - 1.0F) {
						tessellator.setColorRGBA_F(f4 * 0.7F, f5 * 0.7F, f6 * 0.7F, 0.8F);
						tessellator.setNormal(0.0F, -1.0F, 0.0F);
						tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + 0.0F), (double)(f19 + (float)k), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
						tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + 0.0F), (double)(f19 + (float)k), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
						tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + 0.0F), (double)(f19 + 0.0F), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
						tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + 0.0F), (double)(f19 + 0.0F), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
					}

					if(f3 <= f2 + 1.0F) {
						tessellator.setColorRGBA_F(f4, f5, f6, 0.8F);
						tessellator.setNormal(0.0F, 1.0F, 0.0F);
						tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + f2 - f15), (double)(f19 + (float)k), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
						tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + f2 - f15), (double)(f19 + (float)k), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
						tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + f2 - f15), (double)(f19 + 0.0F), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
						tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + f2 - f15), (double)(f19 + 0.0F), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
					}

					tessellator.setColorRGBA_F(f4 * 0.9F, f5 * 0.9F, f6 * 0.9F, 0.8F);
					int j2;
					if(i1 > -1) {
						tessellator.setNormal(-1.0F, 0.0F, 0.0F);

						for(j2 = 0; j2 < k; ++j2) {
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 0.0F), (double)(f3 + 0.0F), (double)(f19 + (float)k), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 0.0F), (double)(f3 + f2), (double)(f19 + (float)k), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 0.0F), (double)(f3 + f2), (double)(f19 + 0.0F), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 0.0F), (double)(f3 + 0.0F), (double)(f19 + 0.0F), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
						}
					}

					if(i1 <= 1) {
						tessellator.setNormal(1.0F, 0.0F, 0.0F);

						for(j2 = 0; j2 < k; ++j2) {
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 1.0F - f15), (double)(f3 + 0.0F), (double)(f19 + (float)k), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 1.0F - f15), (double)(f3 + f2), (double)(f19 + (float)k), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + (float)k) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 1.0F - f15), (double)(f3 + f2), (double)(f19 + 0.0F), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)j2 + 1.0F - f15), (double)(f3 + 0.0F), (double)(f19 + 0.0F), (double)((f16 + (float)j2 + 0.5F) * f12 + f8), (double)((f17 + 0.0F) * f12 + f10));
						}
					}

					tessellator.setColorRGBA_F(f4 * 0.8F, f5 * 0.8F, f6 * 0.8F, 0.8F);
					if(j1 > -1) {
						tessellator.setNormal(0.0F, 0.0F, -1.0F);

						for(j2 = 0; j2 < k; ++j2) {
							tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + f2), (double)(f19 + (float)j2 + 0.0F), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + f2), (double)(f19 + (float)j2 + 0.0F), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + 0.0F), (double)(f19 + (float)j2 + 0.0F), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + 0.0F), (double)(f19 + (float)j2 + 0.0F), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
						}
					}

					if(j1 <= 1) {
						tessellator.setNormal(0.0F, 0.0F, 1.0F);

						for(j2 = 0; j2 < k; ++j2) {
							tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + f2), (double)(f19 + (float)j2 + 1.0F - f15), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + f2), (double)(f19 + (float)j2 + 1.0F - f15), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + (float)k), (double)(f3 + 0.0F), (double)(f19 + (float)j2 + 1.0F - f15), (double)((f16 + (float)k) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
							tessellator.addVertexWithUV((double)(f18 + 0.0F), (double)(f3 + 0.0F), (double)(f19 + (float)j2 + 1.0F - f15), (double)((f16 + 0.0F) * f12 + f8), (double)((f17 + (float)j2 + 0.5F) * f12 + f10));
						}
					}

					tessellator.draw();
				}
			}
		}

		GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);
		GL11.glDisable(GL11.GL_BLEND);
		GL11.glEnable(GL11.GL_CULL_FACE);
	}

	public boolean updateRenderers(EntityLiving entityliving, boolean flag) {
		if(WrUpdates.hasWrUpdater()) {
			return WrUpdates.updateRenderers(this, entityliving, flag);
		} else if(this.worldRenderersToUpdate.size() <= 0) {
			return false;
		} else {
			int num = 0;
			int maxNum = Config.getUpdatesPerFrame();
			if(Config.isDynamicUpdates() && !this.isMoving(entityliving)) {
				maxNum *= 3;
			}

			byte NOT_IN_FRUSTRUM_MUL = 4;
			int numValid = 0;
			WorldRenderer wrBest = null;
			float distSqBest = Float.MAX_VALUE;
			int indexBest = -1;

			int dstIndex;
			for(dstIndex = 0; dstIndex < this.worldRenderersToUpdate.size(); ++dstIndex) {
				WorldRenderer i = (WorldRenderer)this.worldRenderersToUpdate.get(dstIndex);
				if(i != null) {
					++numValid;
					if(!i.needsUpdate) {
						this.worldRenderersToUpdate.set(dstIndex, (Object)null);
					} else {
						float wr = i.distanceToEntitySquared(entityliving);
						if(wr <= 256.0F && this.isActingNow()) {
							i.updateRenderer();
							i.needsUpdate = false;
							this.worldRenderersToUpdate.set(dstIndex, (Object)null);
							++num;
						} else {
							if(wr > 256.0F && num >= maxNum) {
								break;
							}

							if(!i.isInFrustum) {
								wr *= (float)NOT_IN_FRUSTRUM_MUL;
							}

							if(wrBest == null) {
								wrBest = i;
								distSqBest = wr;
								indexBest = dstIndex;
							} else if(wr < distSqBest) {
								wrBest = i;
								distSqBest = wr;
								indexBest = dstIndex;
							}
						}
					}
				}
			}

			int i16;
			if(wrBest != null) {
				wrBest.updateRenderer();
				wrBest.needsUpdate = false;
				this.worldRenderersToUpdate.set(indexBest, (Object)null);
				++num;
				float f15 = distSqBest / 5.0F;

				for(i16 = 0; i16 < this.worldRenderersToUpdate.size() && num < maxNum; ++i16) {
					WorldRenderer worldRenderer17 = (WorldRenderer)this.worldRenderersToUpdate.get(i16);
					if(worldRenderer17 != null) {
						float distSq = worldRenderer17.distanceToEntitySquared(entityliving);
						if(!worldRenderer17.isInFrustum) {
							distSq *= (float)NOT_IN_FRUSTRUM_MUL;
						}

						float diffDistSq = Math.abs(distSq - distSqBest);
						if(diffDistSq < f15) {
							worldRenderer17.updateRenderer();
							worldRenderer17.needsUpdate = false;
							this.worldRenderersToUpdate.set(i16, (Object)null);
							++num;
						}
					}
				}
			}

			if(numValid == 0) {
				this.worldRenderersToUpdate.clear();
			}

			if(this.worldRenderersToUpdate.size() > 100 && numValid < this.worldRenderersToUpdate.size() * 4 / 5) {
				dstIndex = 0;

				for(i16 = 0; i16 < this.worldRenderersToUpdate.size(); ++i16) {
					Object object18 = this.worldRenderersToUpdate.get(i16);
					if(object18 != null) {
						if(i16 != dstIndex) {
							this.worldRenderersToUpdate.set(dstIndex, object18);
						}

						++dstIndex;
					}
				}

				for(i16 = this.worldRenderersToUpdate.size() - 1; i16 >= dstIndex; --i16) {
					this.worldRenderersToUpdate.remove(i16);
				}
			}

			return true;
		}
	}

	public void drawBlockBreaking(EntityPlayer par1EntityPlayer, MovingObjectPosition par2MovingObjectPosition, int par3, ItemStack par4ItemStack, float par5) {
		Tessellator tessellator = Tessellator.instance;
		GL11.glEnable(GL11.GL_BLEND);
		GL11.glEnable(GL11.GL_ALPHA_TEST);
		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE);
		GL11.glColor4f(1.0F, 1.0F, 1.0F, (MathHelper.sin((float)System.currentTimeMillis() / 100.0F) * 0.2F + 0.4F) * 0.5F);
		int k;
		if(par3 == 0) {
			if(this.damagePartialTime > 0.0F) {
				GL11.glBlendFunc(GL11.GL_DST_COLOR, GL11.GL_SRC_COLOR);
				int f = this.renderEngine.getTexture("/terrain.png");
				GL11.glBindTexture(GL11.GL_TEXTURE_2D, f);
				GL11.glColor4f(1.0F, 1.0F, 1.0F, 0.5F);
				GL11.glPushMatrix();
				k = this.worldObj.getBlockId(par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ);
				Block l = k <= 0 ? null : Block.blocksList[k];
				GL11.glDisable(GL11.GL_ALPHA_TEST);
				GL11.glPolygonOffset(-3.0F, -3.0F);
				GL11.glEnable(GL11.GL_POLYGON_OFFSET_FILL);
				double i1 = par1EntityPlayer.lastTickPosX + (par1EntityPlayer.posX - par1EntityPlayer.lastTickPosX) * (double)par5;
				double d1 = par1EntityPlayer.lastTickPosY + (par1EntityPlayer.posY - par1EntityPlayer.lastTickPosY) * (double)par5;
				double d2 = par1EntityPlayer.lastTickPosZ + (par1EntityPlayer.posZ - par1EntityPlayer.lastTickPosZ) * (double)par5;
				if(l == null) {
					l = Block.stone;
				}

				GL11.glEnable(GL11.GL_ALPHA_TEST);
				tessellator.startDrawingQuads();
				tessellator.setTranslation(-i1, -d1, -d2);
				tessellator.disableColor();
				this.globalRenderBlocks.renderBlockUsingTexture(l, par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ, 240 + (int)(this.damagePartialTime * 10.0F));
				tessellator.draw();
				tessellator.setTranslation(0.0D, 0.0D, 0.0D);
				GL11.glDisable(GL11.GL_ALPHA_TEST);
				GL11.glPolygonOffset(0.0F, 0.0F);
				GL11.glDisable(GL11.GL_POLYGON_OFFSET_FILL);
				GL11.glEnable(GL11.GL_ALPHA_TEST);
				GL11.glDepthMask(true);
				GL11.glPopMatrix();
			}
		} else if(par4ItemStack != null) {
			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
			float f16 = MathHelper.sin((float)System.currentTimeMillis() / 100.0F) * 0.2F + 0.8F;
			GL11.glColor4f(f16, f16, f16, MathHelper.sin((float)System.currentTimeMillis() / 200.0F) * 0.2F + 0.5F);
			k = this.renderEngine.getTexture("/terrain.png");
			GL11.glBindTexture(GL11.GL_TEXTURE_2D, k);
			int i17 = par2MovingObjectPosition.blockX;
			int i18 = par2MovingObjectPosition.blockY;
			int j1 = par2MovingObjectPosition.blockZ;
			if(par2MovingObjectPosition.sideHit == 0) {
				--i18;
			}

			if(par2MovingObjectPosition.sideHit == 1) {
				++i18;
			}

			if(par2MovingObjectPosition.sideHit == 2) {
				--j1;
			}

			if(par2MovingObjectPosition.sideHit == 3) {
				++j1;
			}

			if(par2MovingObjectPosition.sideHit == 4) {
				--i17;
			}

			if(par2MovingObjectPosition.sideHit == 5) {
				++i17;
			}
		}

		GL11.glDisable(GL11.GL_BLEND);
		GL11.glDisable(GL11.GL_ALPHA_TEST);
	}

	public void drawSelectionBox(EntityPlayer par1EntityPlayer, MovingObjectPosition par2MovingObjectPosition, int par3, ItemStack par4ItemStack, float par5) {
		if(par3 == 0 && par2MovingObjectPosition.typeOfHit == EnumMovingObjectType.TILE) {
			GL11.glEnable(GL11.GL_BLEND);
			GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
			GL11.glColor4f(0.0F, 0.0F, 0.0F, 0.4F);
			GL11.glLineWidth(2.0F);
			GL11.glDisable(GL11.GL_TEXTURE_2D);
			GL11.glDepthMask(false);
			float f = 0.002F;
			int i = this.worldObj.getBlockId(par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ);
			if(i > 0) {
				Block.blocksList[i].setBlockBoundsBasedOnState(this.worldObj, par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ);
				double d = par1EntityPlayer.lastTickPosX + (par1EntityPlayer.posX - par1EntityPlayer.lastTickPosX) * (double)par5;
				double d1 = par1EntityPlayer.lastTickPosY + (par1EntityPlayer.posY - par1EntityPlayer.lastTickPosY) * (double)par5;
				double d2 = par1EntityPlayer.lastTickPosZ + (par1EntityPlayer.posZ - par1EntityPlayer.lastTickPosZ) * (double)par5;
				this.drawOutlinedBoundingBox(Block.blocksList[i].getSelectedBoundingBoxFromPool(this.worldObj, par2MovingObjectPosition.blockX, par2MovingObjectPosition.blockY, par2MovingObjectPosition.blockZ).expand((double)f, (double)f, (double)f).getOffsetBoundingBox(-d, -d1, -d2));
			}

			GL11.glDepthMask(true);
			GL11.glEnable(GL11.GL_TEXTURE_2D);
			GL11.glDisable(GL11.GL_BLEND);
		}

	}

	private void drawOutlinedBoundingBox(AxisAlignedBB par1AxisAlignedBB) {
		Tessellator tessellator = Tessellator.instance;
		tessellator.startDrawing(3);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.minY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.minY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.minY, par1AxisAlignedBB.maxZ);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.minY, par1AxisAlignedBB.maxZ);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.minY, par1AxisAlignedBB.minZ);
		tessellator.draw();
		tessellator.startDrawing(3);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.maxZ);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.maxZ);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.minZ);
		tessellator.draw();
		tessellator.startDrawing(1);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.minY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.minY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.minZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.minY, par1AxisAlignedBB.maxZ);
		tessellator.addVertex(par1AxisAlignedBB.maxX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.maxZ);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.minY, par1AxisAlignedBB.maxZ);
		tessellator.addVertex(par1AxisAlignedBB.minX, par1AxisAlignedBB.maxY, par1AxisAlignedBB.maxZ);
		tessellator.draw();
	}

	public void markBlocksForUpdate(int par1, int par2, int par3, int par4, int par5, int par6) {
		int i = MathHelper.bucketInt(par1, 16);
		int j = MathHelper.bucketInt(par2, 16);
		int k = MathHelper.bucketInt(par3, 16);
		int l = MathHelper.bucketInt(par4, 16);
		int i1 = MathHelper.bucketInt(par5, 16);
		int j1 = MathHelper.bucketInt(par6, 16);

		for(int k1 = i; k1 <= l; ++k1) {
			int l1 = k1 % this.renderChunksWide;
			if(l1 < 0) {
				l1 += this.renderChunksWide;
			}

			for(int i2 = j; i2 <= i1; ++i2) {
				int j2 = i2 % this.renderChunksTall;
				if(j2 < 0) {
					j2 += this.renderChunksTall;
				}

				for(int k2 = k; k2 <= j1; ++k2) {
					int l2 = k2 % this.renderChunksDeep;
					if(l2 < 0) {
						l2 += this.renderChunksDeep;
					}

					int i3 = (l2 * this.renderChunksTall + j2) * this.renderChunksWide + l1;
					WorldRenderer worldrenderer = this.worldRenderers[i3];
					if(!worldrenderer.needsUpdate) {
						this.worldRenderersToUpdate.add(worldrenderer);
						worldrenderer.markDirty();
					}
				}
			}
		}

	}

	public void markBlockNeedsUpdate(int par1, int par2, int par3) {
		this.markBlocksForUpdate(par1 - 1, par2 - 1, par3 - 1, par1 + 1, par2 + 1, par3 + 1);
	}

	public void markBlockNeedsUpdate2(int par1, int par2, int par3) {
		this.markBlocksForUpdate(par1 - 1, par2 - 1, par3 - 1, par1 + 1, par2 + 1, par3 + 1);
	}

	public void markBlockRangeNeedsUpdate(int par1, int par2, int par3, int par4, int par5, int par6) {
		this.markBlocksForUpdate(par1 - 1, par2 - 1, par3 - 1, par4 + 1, par5 + 1, par6 + 1);
	}

	public void clipRenderersByFrustum(ICamera par1ICamera, float par2) {
		for(int i = 0; i < this.worldRenderers.length; ++i) {
			if(!this.worldRenderers[i].skipAllRenderPasses()) {
				this.worldRenderers[i].updateInFrustum(par1ICamera);
			}
		}

		++this.frustumCheckOffset;
	}

	public void playRecord(String par1Str, int par2, int par3, int par4) {
		if(par1Str != null) {
			this.mc.ingameGUI.setRecordPlayingMessage("C418 - " + par1Str);
		}

		this.mc.sndManager.playStreaming(par1Str, (float)par2, (float)par3, (float)par4, 1.0F, 1.0F);
	}

	public void playSound(String par1Str, double par2, double par4, double par6, float par8, float par9) {
		float f = 16.0F;
		if(par8 > 1.0F) {
			f *= par8;
		}

		if(this.mc.renderViewEntity.getDistanceSq(par2, par4, par6) < (double)(f * f)) {
			this.mc.sndManager.playSound(par1Str, (float)par2, (float)par4, (float)par6, par8, par9);
		}

	}

	public void spawnParticle(String par1Str, double par2, double par4, double par6, double par8, double par10, double par12) {
		this.func_40193_b(par1Str, par2, par4, par6, par8, par10, par12);
	}

	public EntityFX func_40193_b(String par1Str, double par2, double par4, double par6, double par8, double par10, double par12) {
		if(this.mc != null && this.mc.renderViewEntity != null && this.mc.effectRenderer != null) {
			int i = this.mc.gameSettings.particleSetting;
			if(i == 1 && this.worldObj.rand.nextInt(3) == 0) {
				i = 2;
			}

			double d = this.mc.renderViewEntity.posX - par2;
			double d1 = this.mc.renderViewEntity.posY - par4;
			double d2 = this.mc.renderViewEntity.posZ - par6;
			Object obj = null;
			Item effectObject = null;
			if(par1Str.equals("hugeexplosion")) {
				if(Config.isAnimatedExplosion()) {
					this.mc.effectRenderer.addEffect((EntityFX)(obj = new EntityHugeExplodeFX(this.worldObj, par2, par4, par6, par8, par10, par12)));
				}
			} else if(par1Str.equals("largeexplode") && Config.isAnimatedExplosion()) {
				this.mc.effectRenderer.addEffect((EntityFX)(obj = new EntityLargeExplodeFX(this.renderEngine, this.worldObj, par2, par4, par6, par8, par10, par12)));
			}

			if(obj != null) {
				return (EntityFX)((EntityFX)obj);
			} else {
				double d3 = 16.0D;
				if(par1Str.equals("crit")) {
					d3 = 196.0D;
				}

				if(d * d + d1 * d1 + d2 * d2 > d3 * d3) {
					return null;
				} else if(i > 1) {
					return null;
				} else {
					if(par1Str.equals("bubble")) {
						obj = new EntityBubbleFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						CustomColorizer.updateWaterFX((EntityFX)obj, this.worldObj);
					} else if(par1Str.equals("suspended")) {
						if(Config.isWaterParticles()) {
							obj = new EntitySuspendFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						}
					} else if(par1Str.equals("depthsuspend")) {
						if(Config.isVoidParticles()) {
							obj = new EntityAuraFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						}
					} else if(par1Str.equals("townaura")) {
						obj = new EntityAuraFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						CustomColorizer.updateMyceliumFX((EntityFX)obj);
					} else if(par1Str.equals("crit")) {
						obj = new EntityCritFX(this.worldObj, par2, par4, par6, par8, par10, par12);
					} else if(par1Str.equals("magicCrit")) {
						obj = new EntityCritFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						((EntityFX)((EntityFX)obj)).func_40097_b(((EntityFX)((EntityFX)obj)).func_40098_n() * 0.3F, ((EntityFX)((EntityFX)obj)).func_40101_o() * 0.8F, ((EntityFX)((EntityFX)obj)).func_40102_p());
						((EntityFX)((EntityFX)obj)).setParticleTextureIndex(((EntityFX)((EntityFX)obj)).getParticleTextureIndex() + 1);
					} else if(par1Str.equals("smoke")) {
						if(Config.isAnimatedSmoke()) {
							obj = new EntitySmokeFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						}
					} else if(par1Str.equals("mobSpell")) {
						obj = new EntitySpellParticleFX(this.worldObj, par2, par4, par6, 0.0D, 0.0D, 0.0D);
						((EntityFX)((EntityFX)obj)).func_40097_b((float)par8, (float)par10, (float)par12);
					} else if(par1Str.equals("spell")) {
						obj = new EntitySpellParticleFX(this.worldObj, par2, par4, par6, par8, par10, par12);
					} else if(par1Str.equals("instantSpell")) {
						obj = new EntitySpellParticleFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						((EntitySpellParticleFX)obj).func_40110_b(144);
					} else if(par1Str.equals("note")) {
						obj = new EntityNoteFX(this.worldObj, par2, par4, par6, par8, par10, par12);
					} else if(par1Str.equals("portal")) {
						if(Config.isPortalParticles()) {
							obj = new EntityPortalFX(this.worldObj, par2, par4, par6, par8, par10, par12);
							CustomColorizer.updatePortalFX((EntityFX)obj);
						}
					} else if(par1Str.equals("enchantmenttable")) {
						obj = new EntityEnchantmentTableParticleFX(this.worldObj, par2, par4, par6, par8, par10, par12);
					} else if(par1Str.equals("explode")) {
						if(Config.isAnimatedExplosion()) {
							obj = new EntityExplodeFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						}
					} else if(par1Str.equals("flame")) {
						if(Config.isAnimatedFlame()) {
							obj = new EntityFlameFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						}
					} else if(par1Str.equals("lava")) {
						obj = new EntityLavaFX(this.worldObj, par2, par4, par6);
					} else if(par1Str.equals("footstep")) {
						obj = new EntityFootStepFX(this.renderEngine, this.worldObj, par2, par4, par6);
					} else if(par1Str.equals("splash")) {
						obj = new EntitySplashFX(this.worldObj, par2, par4, par6, par8, par10, par12);
						CustomColorizer.updateWaterFX((EntityFX)obj, this.worldObj);
					} else if(par1Str.equals("largesmoke")) {
						if(Config.isAnimatedSmoke()) {
							obj = new EntitySmokeFX(this.worldObj, par2, par4, par6, par8, par10, par12, 2.5F);
						}
					} else if(par1Str.equals("cloud")) {
						obj = new EntityCloudFX(this.worldObj, par2, par4, par6, par8, par10, par12);
					} else if(par1Str.equals("reddust")) {
						if(Config.isAnimatedRedstone()) {
							obj = new EntityReddustFX(this.worldObj, par2, par4, par6, (float)par8, (float)par10, (float)par12);
							CustomColorizer.updateReddustFX((EntityFX)obj, this.worldObj, d, d1, d2);
						}
					} else if(par1Str.equals("snowballpoof")) {
						obj = new EntityBreakingFX(this.worldObj, par2, par4, par6, Item.snowball);
						effectObject = Item.snowball;
					} else if(par1Str.equals("dripWater")) {
						if(Config.isDrippingWaterLava()) {
							obj = new EntityDropParticleFX(this.worldObj, par2, par4, par6, Material.water);
						}
					} else if(par1Str.equals("dripLava")) {
						if(Config.isDrippingWaterLava()) {
							obj = new EntityDropParticleFX(this.worldObj, par2, par4, par6, Material.lava);
						}
					} else if(par1Str.equals("snowshovel")) {
						obj = new EntitySnowShovelFX(this.worldObj, par2, par4, par6, par8, par10, par12);
					} else if(par1Str.equals("slime")) {
						obj = new EntityBreakingFX(this.worldObj, par2, par4, par6, Item.slimeBall);
						effectObject = Item.slimeBall;
					} else if(par1Str.equals("heart")) {
						obj = new EntityHeartFX(this.worldObj, par2, par4, par6, par8, par10, par12);
					} else {
						int k;
						if(par1Str.startsWith("iconcrack_")) {
							k = Integer.parseInt(par1Str.substring(par1Str.indexOf("_") + 1));
							obj = new EntityBreakingFX(this.worldObj, par2, par4, par6, par8, par10, par12, Item.itemsList[k]);
							effectObject = Item.itemsList[k];
						} else if(par1Str.startsWith("tilecrack_")) {
							k = Integer.parseInt(par1Str.substring(par1Str.indexOf("_") + 1));
							obj = new EntityDiggingFX(this.worldObj, par2, par4, par6, par8, par10, par12, Block.blocksList[k], 0, 0);
							effectObject = Item.itemsList[k];
						}
					}

					if(obj != null) {
						if(Reflector.hasClass(1)) {
							Reflector.callVoid(this.mc.effectRenderer, 80, new Object[]{obj, effectObject});
						} else {
							this.mc.effectRenderer.addEffect((EntityFX)((EntityFX)obj));
						}
					}

					return (EntityFX)((EntityFX)obj);
				}
			}
		} else {
			return null;
		}
	}

	public void obtainEntitySkin(Entity par1Entity) {
		par1Entity.updateCloak();
		if(par1Entity.skinUrl != null && par1Entity.skinUrl.startsWith("http")) {
			this.renderEngine.obtainImageData(par1Entity.skinUrl, new ImageBufferDownload());
		}

		if(par1Entity.cloakUrl != null) {
			this.renderEngine.obtainImageData(par1Entity.cloakUrl, new ImageBufferDownload());
			if(par1Entity instanceof EntityPlayer) {
				EntityPlayer player = (EntityPlayer)par1Entity;
				ThreadDownloadImageData tdid = this.renderEngine.obtainImageData(player.cloakUrl, new ImageBufferDownload());
				this.renderEngine.releaseImageData(player.cloakUrl);
				String urlStr = "http://optifine.net/capes/" + player.username + ".png";
				ThreadDownloadImage tdi = new ThreadDownloadImage(tdid, urlStr, new ImageBufferDownload());
				tdi.start();
				if(!Config.isShowCapes()) {
					player.playerCloakUrl = "";
				}
			}
		}

		if(Config.isRandomMobs()) {
			RandomMobs.entityLoaded(par1Entity);
		}

	}

	public void releaseEntitySkin(Entity par1Entity) {
		if(par1Entity.skinUrl != null) {
			this.renderEngine.releaseImageData(par1Entity.skinUrl);
		}

		if(par1Entity.cloakUrl != null) {
			this.renderEngine.releaseImageData(par1Entity.cloakUrl);
		}

	}

	public void setAllRenderersVisible() {
		if(this.worldRenderers != null) {
			for(int i = 0; i < this.worldRenderers.length; ++i) {
				this.worldRenderers[i].isVisible = true;
			}

		}
	}

	public void doNothingWithTileEntity(int i, int j, int k, TileEntity tileentity) {
	}

	public void func_28137_f() {
		GLAllocation.deleteDisplayLists(this.glRenderListBase);
	}

	public void playAuxSFX(EntityPlayer par1EntityPlayer, int par2, int par3, int par4, int par5, int par6) {
		Random random = this.worldObj.rand;
		double d5;
		double d9;
		int j;
		double d49;
		switch(par2) {
		case 1000:
			this.worldObj.playSoundEffect((double)par3, (double)par4, (double)par5, "random.click", 1.0F, 1.0F);
			break;
		case 1001:
			this.worldObj.playSoundEffect((double)par3, (double)par4, (double)par5, "random.click", 1.0F, 1.2F);
			break;
		case 1002:
			this.worldObj.playSoundEffect((double)par3, (double)par4, (double)par5, "random.bow", 1.0F, 1.2F);
			break;
		case 1003:
			if(Math.random() < 0.5D) {
				this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "random.door_open", 1.0F, this.worldObj.rand.nextFloat() * 0.1F + 0.9F);
			} else {
				this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "random.door_close", 1.0F, this.worldObj.rand.nextFloat() * 0.1F + 0.9F);
			}
			break;
		case 1004:
			this.worldObj.playSoundEffect((double)((float)par3 + 0.5F), (double)((float)par4 + 0.5F), (double)((float)par5 + 0.5F), "random.fizz", 0.5F, 2.6F + (random.nextFloat() - random.nextFloat()) * 0.8F);
			break;
		case 1005:
			if(Item.itemsList[par6] instanceof ItemRecord) {
				this.worldObj.playRecord(((ItemRecord)Item.itemsList[par6]).recordName, par3, par4, par5);
			} else {
				this.worldObj.playRecord((String)null, par3, par4, par5);
			}
			break;
		case 1007:
			this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "mob.ghast.charge", 10.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F);
			break;
		case 1008:
			this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "mob.ghast.fireball", 10.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F);
			break;
		case 1010:
			this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "mob.zombie.wood", 2.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F);
			break;
		case 1011:
			this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "mob.zombie.metal", 2.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F);
			break;
		case 1012:
			this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "mob.zombie.woodbreak", 2.0F, (random.nextFloat() - random.nextFloat()) * 0.2F + 1.0F);
			break;
		case 2000:
			int i = par6 % 3 - 1;
			int l = par6 / 3 % 3 - 1;
			double d3 = (double)par3 + (double)i * 0.6D + 0.5D;
			double d7 = (double)par4 + 0.5D;
			double d11 = (double)par5 + (double)l * 0.6D + 0.5D;

			for(int i48 = 0; i48 < 10; ++i48) {
				double d13 = random.nextDouble() * 0.2D + 0.01D;
				double d14 = d3 + (double)i * 0.01D + (random.nextDouble() - 0.5D) * (double)l * 0.5D;
				double d15 = d7 + (random.nextDouble() - 0.5D) * 0.5D;
				d49 = d11 + (double)l * 0.01D + (random.nextDouble() - 0.5D) * (double)i * 0.5D;
				d5 = (double)i * d13 + random.nextGaussian() * 0.01D;
				d9 = -0.03D + random.nextGaussian() * 0.01D;
				double d50 = (double)l * d13 + random.nextGaussian() * 0.01D;
				this.spawnParticle("smoke", d14, d15, d49, d5, d9, d50);
			}

			return;
		case 2001:
			j = par6 & 4095;
			if(j > 0) {
				Block block52 = Block.blocksList[j];
				this.mc.sndManager.playSound(block52.stepSound.getBreakSound(), (float)par3 + 0.5F, (float)par4 + 0.5F, (float)par5 + 0.5F, (block52.stepSound.getVolume() + 1.0F) / 2.0F, block52.stepSound.getPitch() * 0.8F);
			}

			this.mc.effectRenderer.addBlockDestroyEffects(par3, par4, par5, par6 & 4095, par6 >> 12 & 255);
			break;
		case 2002:
			d49 = (double)par3;
			d5 = (double)par4;
			d9 = (double)par5;
			String s1 = "iconcrack_" + Item.potion.shiftedIndex;

			int k1;
			for(k1 = 0; k1 < 8; ++k1) {
				this.spawnParticle(s1, d49, d5, d9, random.nextGaussian() * 0.15D, random.nextDouble() * 0.2D, random.nextGaussian() * 0.15D);
			}

			k1 = Item.potion.getColorFromDamage(par6, 0);
			float f = (float)(k1 >> 16 & 255) / 255.0F;
			float f1 = (float)(k1 >> 8 & 255) / 255.0F;
			float f2 = (float)(k1 >> 0 & 255) / 255.0F;
			String s2 = "spell";
			if(Item.potion.isEffectInstant(par6)) {
				s2 = "instantSpell";
			}

			for(j = 0; j < 100; ++j) {
				double d51 = random.nextDouble() * 4.0D;
				double d18 = random.nextDouble() * Math.PI * 2.0D;
				double d20 = Math.cos(d18) * d51;
				double d22 = 0.01D + random.nextDouble() * 0.5D;
				double d24 = Math.sin(d18) * d51;
				EntityFX entityfx = this.func_40193_b(s2, d49 + d20 * 0.1D, d5 + 0.3D, d9 + d24 * 0.1D, d20, d22, d24);
				if(entityfx != null) {
					float f3 = 0.75F + random.nextFloat() * 0.25F;
					entityfx.func_40097_b(f * f3, f1 * f3, f2 * f3);
					entityfx.multiplyVelocity((float)d51);
				}
			}

			this.worldObj.playSoundEffect((double)par3 + 0.5D, (double)par4 + 0.5D, (double)par5 + 0.5D, "random.glass", 1.0F, this.worldObj.rand.nextFloat() * 0.1F + 0.9F);
			break;
		case 2003:
			double d = (double)par3 + 0.5D;
			double d4 = (double)par4;
			double d8 = (double)par5 + 0.5D;
			String s = "iconcrack_" + Item.eyeOfEnder.shiftedIndex;

			for(int d1 = 0; d1 < 8; ++d1) {
				this.spawnParticle(s, d, d4, d8, random.nextGaussian() * 0.15D, random.nextDouble() * 0.2D, random.nextGaussian() * 0.15D);
			}

			for(d49 = 0.0D; d49 < Math.PI * 2D; d49 += 0.15707963267948966D) {
				this.spawnParticle("portal", d + Math.cos(d49) * 5.0D, d4 - 0.4D, d8 + Math.sin(d49) * 5.0D, Math.cos(d49) * -5.0D, 0.0D, Math.sin(d49) * -5.0D);
				this.spawnParticle("portal", d + Math.cos(d49) * 5.0D, d4 - 0.4D, d8 + Math.sin(d49) * 5.0D, Math.cos(d49) * -7.0D, 0.0D, Math.sin(d49) * -7.0D);
			}

			return;
		case 2004:
			for(int k = 0; k < 20; ++k) {
				double d2 = (double)par3 + 0.5D + ((double)this.worldObj.rand.nextFloat() - 0.5D) * 2.0D;
				double d6 = (double)par4 + 0.5D + ((double)this.worldObj.rand.nextFloat() - 0.5D) * 2.0D;
				double d10 = (double)par5 + 0.5D + ((double)this.worldObj.rand.nextFloat() - 0.5D) * 2.0D;
				this.worldObj.spawnParticle("smoke", d2, d6, d10, 0.0D, 0.0D, 0.0D);
				this.worldObj.spawnParticle("flame", d2, d6, d10, 0.0D, 0.0D, 0.0D);
			}
		}

	}

	public boolean isMoving(EntityLiving entityliving) {
		boolean moving = this.isMovingNow(entityliving);
		if(moving) {
			this.lastMovedTime = System.currentTimeMillis();
			return true;
		} else {
			return System.currentTimeMillis() - this.lastMovedTime < 2000L;
		}
	}

	private boolean isMovingNow(EntityLiving entityliving) {
		double maxDiff = 0.001D;
		return entityliving.isJumping ? true : (entityliving.isSneaking() ? true : ((double)entityliving.prevSwingProgress > maxDiff ? true : (this.mc.mouseHelper.deltaX != 0 ? true : (this.mc.mouseHelper.deltaY != 0 ? true : (Math.abs(entityliving.posX - entityliving.prevPosX) > maxDiff ? true : (Math.abs(entityliving.posY - entityliving.prevPosY) > maxDiff ? true : Math.abs(entityliving.posZ - entityliving.prevPosZ) > maxDiff))))));
	}

	public boolean isActing() {
		boolean acting = this.isActingNow();
		if(acting) {
			this.lastActionTime = System.currentTimeMillis();
			return true;
		} else {
			return System.currentTimeMillis() - this.lastActionTime < 500L;
		}
	}

	public boolean isActingNow() {
		return Mouse.isButtonDown(0) ? true : Mouse.isButtonDown(1);
	}

	public int renderAllSortedRenderers(int renderPass, double partialTicks) {
		return this.renderSortedRenderers(0, this.sortedWorldRenderers.length, renderPass, partialTicks);
	}

	public void updateCapes() {
		if(this.worldObj != null) {
			boolean showCapes = Config.isShowCapes();
			List playerList = this.worldObj.playerEntities;

			for(int i = 0; i < playerList.size(); ++i) {
				Entity entity = (Entity)playerList.get(i);
				if(entity instanceof EntityPlayer) {
					EntityPlayer player = (EntityPlayer)entity;
					if(showCapes) {
						player.playerCloakUrl = player.cloakUrl;
					} else {
						player.playerCloakUrl = "";
					}
				}
			}

		}
	}
}
